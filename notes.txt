mapping (address => uint)

public contract methods
================
constructor payable
createJob(totalWorkRequired)
contribute(address, numberOfWorks)

contract notes
===============
may be a good idea to separate the logic of paying workers
making a splitter contract that saves off worker's balances and requires them to get them would be good, but it means that workers would need existing funds to send the transaction getting those wages
at gas limit 4712388 without a splitter contract, we are able to pay out about 217 workers.
when users visit the site, we can react to if they have web3. This pattern may require splitting the contract into multiple contracts
    -if no web3, they contribute to the automatic payout contract. This contract means payouts happen automatically with automated gas levels
    -if web3, they get to 1. see their progress and balance in real time by inspecting the blockchain and 2. Withdraw their money as frequently or infrequently as possible

server lib
=================
Currently, the server is paying the gas fee for every transaction
    -This means that any user that gives contributions to a contract that has a fallback function that consumes gas can exert extra gas from the server.
    -This means we could also be attacked by a user splitting all of his contributions across many accounts

public rest endpoints
===============
GET /job
    -returns {seed, controller, jobId}
GET /jobBytecode/{jobId}
    -returns 0xbytecodez
POST /result/{jobId}
    -header: ethAddress
    -postBody {fitness, workCredits, seed}
